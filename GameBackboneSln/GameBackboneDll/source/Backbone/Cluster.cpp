#include <Backbone\Cluster.h>
#include <Util\Array2D.h>

#include <SFML\Graphics\Sprite.hpp>

#include <set>
#include <tuple>
#include <map>

using namespace GB;

// also functions as the setter
// random number generated by caller is passed in
Cluster::Cluster(std::pair<int, int> firstPoint, std::multimap<std::pair<int, int>, Cluster>& pointToClusterMap, std::pair<int, int> dimensions) {
    this->pointToClusterMap = &pointToClusterMap;
    dimensionsOfGrid = dimensions;
    clusterPointSet.insert(firstPoint);
    UpdateBorder(firstPoint);
    //this->pointToClusterMap->insert(std::make_pair(firstPoint, *this));
}

//getter
std::set<std::pair<int, int>>* Cluster::getClusterPoints() {
    return &clusterPointSet;
}

ClusterGenerationOptions* Cluster::getClusterGenerationOptions() {
    return &clusterOptions;
}

//setter
void Cluster::setClusterGenerationOptions(ClusterGenerationOptions* OptionsForThisCluster) {
    clusterOptions = *OptionsForThisCluster;
}

bool Cluster::addPointToCluster(int randomNumber) {
    moveIterator(randomNumber);
        for (int i = 0; i < borderPointSet.size(); i++) {
            // If the point is not already in a different cluster and also not on the edge
            // of the graph, we're good
            if (pointToClusterMap->find(*borderPointSetIter) == pointToClusterMap->end() &&
                dimensionsOfGrid.first > borderPointSetIter->first && dimensionsOfGrid.second > borderPointSetIter->second) {
                std::pair<int, int> pointToAdd = *borderPointSetIter;
                clusterPointSet.insert(pointToAdd);
                UpdateBorder(pointToAdd);
                pointToClusterMap->insert(std::make_pair(pointToAdd, *this));
                return true;
            }
            // Otherwise, check the next point in the set
            else {
                borderPointSetIter++;
                if (borderPointSetIter == borderPointSet.end()) {
                    borderPointSetIter = borderPointSet.begin();
                }
            }
        }
    return false;
}        

// This moves the border's iterator some number, maintaining the circular border
void Cluster::moveIterator(int& numberToMove) {
    numberToMove = numberToMove%borderPointSet.size();
    if (numberToMove >= 0) {
        borderPointSetIter = borderPointSet.begin();
        std::advance(borderPointSetIter, numberToMove);
    }
    else {
        borderPointSetIter = borderPointSet.end();
        std::advance(borderPointSetIter, numberToMove - 1);
    }
}

void Cluster::UpdateBorder(std::pair<int, int> pointToAdd) {
    borderPointSet.insert(std::pair<int, int>(pointToAdd.first, pointToAdd.second + 1));
    borderPointSet.insert(std::pair<int, int>(pointToAdd.first + 1, pointToAdd.second));
    borderPointSet.insert(std::pair<int, int>(pointToAdd.first, pointToAdd.second - 1));
    borderPointSet.insert(std::pair<int, int>(pointToAdd.first - 1, pointToAdd.second));
    borderPointSet.erase(pointToAdd);
    borderPointSetIter = borderPointSet.begin();
}